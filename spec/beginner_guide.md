# 人话版入门：资源调度防爆项目

更新时间：2026-02-09（UTC+08:00）

## 1. 这项目是干什么的
一句话：
盯着你电脑的 CPU、GPU、内存，按实时状态安排任务，尽量避免“内存爆掉、机器卡死/重启”。

---

## 2. 为什么需要它
如果你同时跑很多任务，常见情况是：
1. CPU 长时间 100%，系统变卡。
2. 内存被吃满，程序被系统强杀。
3. GPU 显存爆掉，训练/推理直接报错。

所以要有一个“交通警察”：
1. 资源健康时放行。
2. 资源紧张时限流。
3. 快崩了就紧急刹车+回收。

---

## 3. 你可以这样理解核心逻辑
系统每隔一小段时间（比如 0.5 秒）做一次检查：
1. 先看资源（CPU/内存/GPU）。
2. 判断现在是正常、紧张还是危险。
3. 根据状态决定是否启动新任务。
4. 危险时优先终止低优先级任务保命。

这就像开车：
1. 绿灯（NORMAL）正常走。
2. 黄灯（HIGH）减速。
3. 红灯（EMERGENCY）停车并清障。

---

## 4. “防爆”到底怎么做
有三道防线：
1. **启动前预测**：新任务会不会把内存顶爆？会就不让启动。
2. **高水位限流**：内存/CPU过高时，减少并发，只跑重点任务。
3. **紧急回收**：进入危险区时，主动终止低优先级任务。

---

## 5. 你最关心的问题：能不能彻底防重启？
结论：
1. 能显著降低风险；
2. 但不能承诺 100% 杜绝重启。

原因：
1. 还有系统外部进程和驱动因素；
2. 硬件/驱动异常不受调度器完全控制。

这个项目做的是“最大化稳定性”，不是“绝对不出事故”。

---

## 6. 现在这个仓库里看哪几个文件
按这个顺序看：
1. `spec/beginner_guide.md`（本文件）
2. `spec/architecture.md`（整体结构）
3. `spec/algorithm_pseudocode.md`（流程）
4. `prototype/resource_scheduler.py`（核心实现）
5. `prototype/main.py`（演示入口）
6. `prototype/tests/test_resource_scheduler.py`（可验证逻辑）

---

## 7. 零基础怎么判断“它有没有用”
你不需要懂复杂数学，只要看这几个结果：
1. 紧急模式时，是否真的停止新任务。
2. 是否会主动回收低优先级任务。
3. 关键任务是否比普通任务更容易被放行。
4. 日志是否能解释“为什么阻断/为什么回收”。

如果这 4 点成立，系统就是在发挥作用。
